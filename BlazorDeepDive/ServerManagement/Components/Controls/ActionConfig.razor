@rendermode InteractiveServer
@using ServerManagement.Models
@using ServerManagement.Handlers
@using Microsoft.FluentUI.AspNetCore.Components
@inject IEnumerable<IActionHandler> Handlers

<style>
    .action-card {
        margin-bottom: 1.5rem;
        padding: 1rem;
        box-sizing: border-box;
        width: 100%;
    }

    .action-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 1rem;
        flex-wrap: wrap;
    }

    .action-header-left {
        display: flex;
        align-items: center;
        gap: 1rem;
        flex-wrap: wrap;
        min-width: 0;
    }

        .action-header-left span {
            font-weight: 100;
            white-space: nowrap;
        }

    .action-toolbar {
        display: flex;
        gap: 0.5rem;
        flex-shrink: 0;
    }

    .action-body {
        min-height: 250px;
        max-height: 55vh;
        overflow: auto;
        padding-bottom: 0.25rem;
        margin-top: 0.75rem;
        box-sizing: border-box;
    }

    .empty-state {
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 250px;
    }

    @@media (max-width:900px) {
        .action-header {
            flex-direction: column;
            align-items: stretch;
        }

        .action-toolbar {
            justify-content: flex-start;
        }
    }

    @@media (max-width:750px) {
        .action-body .instrument-grid {
            grid-template-columns: 1fr !important;
        }
    }
</style>

<FluentCard AreaRestricted="false" Class="action-card">
    <div class="action-header">
        <div class="action-header-left">
            <span>Action @(Index + 1):</span>
            <FluentSelect TOption="string"
                          Value="@GetSelectedValue()"
                          ValueChanged="@OnTypeChanged"
                          Placeholder="-- Select Option --"
                          Style="width:220px;">
                @foreach (var type in ActionTypes.Where(t => t != ActionType.None))
                {
                    <FluentOption Value="@type.ToString()">@GetDisplayName(type)</FluentOption>
                }
            </FluentSelect>
        </div>
        <div class="action-toolbar">
            <FluentButton BackgroundColor="#1976d2"
                          Disabled="@(Item.Type == ActionType.None)"
                          OnClick="@(() => OnCopy.InvokeAsync(Item))">
                <FluentIcon Icon="@(Icons.Regular.Size24.Copy)" Style="fill:white;" />
            </FluentButton>
            <FluentButton BackgroundColor="#1976d2" OnClick="@(() => OnDelete.InvokeAsync())">
                <FluentIcon Icon="@(Icons.Regular.Size24.Delete)" Style="fill:white;" />
            </FluentButton>
        </div>
    </div>
    <hr style="border:medium; color:dimgrey; margin:0.75rem 0;" />
    <div class="action-body">
        @if (Item.Type == ActionType.LisOrder && Item is LisOrderActionModel lisModel)
        {
            <LisOrder @ref="lisOrderRef" Model="@lisModel" />
        }
        else if (Item.Type == ActionType.InstrumentResult && Item is InstrumentResultActionModel instModel)
        {
            <InstrumentResult @ref="instrumentResultRef" Model="@instModel" />
        }
        else
        {
            <div class="empty-state">
                <p style="color:gray; text-align:center; margin:0; opacity:0.8;">
                    ℹ️ Please select required action
                </p>
            </div>
        }
    </div>
</FluentCard>

@code {
    [Parameter] public ActionModel Item { get; set; } = default!;
    [Parameter] public int Index { get; set; }
    [Parameter] public EventCallback<ActionModel> OnCopy { get; set; }
    [Parameter] public EventCallback OnDelete { get; set; }
    [Parameter] public EventCallback<IStepNode> OnActionChanged { get; set; }
    [Parameter] public bool ShouldValidate { get; set; }
    [Parameter] public EventCallback<bool> ShouldValidateChanged { get; set; }
    private readonly List<ActionType> ActionTypes = Enum.GetValues<ActionType>().ToList();
    private LisOrder? lisOrderRef;
    private InstrumentResult? instrumentResultRef;
    private bool lastShouldValidate = false;

    protected override void OnParametersSet()
    {
        if (ShouldValidate && !lastShouldValidate)
        {
            lastShouldValidate = true;
            ValidateAction();
        }
        else if (!ShouldValidate)
        {
            lastShouldValidate = false;
        }
    }

    public bool ValidateAction()
    {
        if (Item.Type == ActionType.LisOrder && lisOrderRef != null)
        {
            return lisOrderRef.Validate();
        }
        else if (Item.Type == ActionType.InstrumentResult && instrumentResultRef != null)
        {
            return instrumentResultRef.Validate();
        }
        return true;
    }

    private string GetSelectedValue()
    {
        return Item.Type == ActionType.None ? "" : Item.Type.ToString();
    }

    private async Task OnTypeChanged(string value)
    {
        if (string.IsNullOrWhiteSpace(value)) return;
        if (!Enum.TryParse<ActionType>(value, out var newType)) return;

        var handler = Handlers.FirstOrDefault(h => h.SupportedType == newType);
        if (handler is null) return;

        var newAction = handler.CreateDefaultModel();
        await OnActionChanged.InvokeAsync(newAction);
    }

    private static string GetDisplayName(ActionType actionType)
    {
        var info = typeof(ActionType).GetMember(actionType.ToString());
        if (info.Length == 0) return actionType.ToString();

        var attr = info[0].GetCustomAttributes(typeof(System.ComponentModel.DataAnnotations.DisplayAttribute), false);
        return attr.Length > 0
            ? ((System.ComponentModel.DataAnnotations.DisplayAttribute)attr[0]).Name ?? actionType.ToString()
            : actionType.ToString();
    }
}