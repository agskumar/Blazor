@rendermode InteractiveServer
@using ServerManagement.Models
@using ServerManagement.Handlers
@using Microsoft.FluentUI.AspNetCore.Components
@inject IEnumerable<IActionHandler> Handlers

<style>
    .action-card {
        margin-bottom:1.5rem;
        padding:1rem;
        box-sizing:border-box;
        width:100%;
    }

    .action-header {
        display:flex;
        align-items:center;
        justify-content:space-between;
        gap:1rem;
        flex-wrap:wrap;
    }

    .action-header-left {
        display:flex;
        align-items:center;
        gap:1rem;
        flex-wrap:wrap;
        min-width:0;
    }

    .action-header-left span {
        font-weight:100;
        white-space:nowrap;
    }

    .action-toolbar {
        display:flex;
        gap:0.5rem;
        flex-shrink:0;
    }

    .action-body {
        min-height:250px;
        max-height:55vh;
        overflow:auto; 
        padding-bottom:0.25rem;
        margin-top:0.75rem;
        box-sizing:border-box;
    }

    .empty-state {
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 250px;
    }

    @@media (max-width:900px) {
        .action-header {
            flex-direction:column;
            align-items:stretch;
        }

        .action-toolbar {
            justify-content:flex-start;
        }
    }

    @@media (max-width:750px) {
        .action-body .instrument-grid {
            grid-template-columns:1fr !important;
        }
    }
</style>

<FluentCard AreaRestricted="false" Class="action-card">
    <div class="action-header">
        <div class="action-header-left">
            <span>Action @ActionNumber:</span>
            <FluentSelect TOption="string"
                          Value="@GetSelectedValue()"
                          ValueChanged="@OnTypeChanged"
                          Placeholder="-- Select Option --"
                          Style="width:220px;">
                @foreach (var type in ActionTypes.Where(t => t != ActionType.None))
                {
                    <FluentOption Value="@type.ToString()">@GetDisplayName(type)</FluentOption>
                }
            </FluentSelect>
        </div>

        <div class="action-toolbar">
            <FluentButton BackgroundColor="#1976d2"
                          Disabled="@(Action.Type == ActionType.None)"
                          OnClick="@(() => CopyAction.InvokeAsync(Action))">
                <FluentIcon Icon="@(Icons.Regular.Size24.Copy)" Style="fill:white;" />
            </FluentButton>

            <FluentButton BackgroundColor="#1976d2" OnClick="@(() => DeleteAction.InvokeAsync())">
                <FluentIcon Icon="@(Icons.Regular.Size24.Delete)" Style="fill:white;" />
            </FluentButton>
        </div>
    </div>
            
    <hr style="border:medium; color:dimgrey; margin:0.75rem 0;" />

    <div class="action-body">
        @if (Action.Type == ActionType.LisOrder && Action is LisOrderActionModel lisModel)
        {
            <LisOrder @ref="lisOrderRef" Model="@lisModel" />
        }
        else if (Action.Type == ActionType.InstrumentResult && Action is InstrumentResultActionModel instModel)
        {
            <InstrumentResult @ref="instrumentResultRef" Model="@instModel" />
        }
        else
        {
            <div class="empty-state">
                <p style="color:gray; text-align:center; margin:0; opacity:0.8;">
                    ℹ️ Please select required action
                </p>
            </div>
        }
    </div>
</FluentCard>

@code {
    [Parameter] public ActionModel Action { get; set; } = default!;
    [Parameter] public int ActionNumber { get; set; }
    [Parameter] public EventCallback<ActionModel> CopyAction { get; set; }
    [Parameter] public EventCallback DeleteAction { get; set; }
    [Parameter] public EventCallback<ActionModel> OnActionChanged { get; set; }

    private readonly List<ActionType> ActionTypes = Enum.GetValues<ActionType>().ToList();
    private LisOrder? lisOrderRef;
    private InstrumentResult? instrumentResultRef;

    public bool ValidateAction()
    {
        if (Action.Type == ActionType.LisOrder && lisOrderRef != null)
        {
            return lisOrderRef.Validate();
        }
        else if (Action.Type == ActionType.InstrumentResult && instrumentResultRef != null)
        {
            return instrumentResultRef.Validate();
        }
        return true;
    }

    private string GetSelectedValue() =>
        Action.Type == ActionType.None ? "" : Action.Type.ToString();

    private async Task OnTypeChanged(string value)
    {
        if (string.IsNullOrWhiteSpace(value)) return;
        if (!Enum.TryParse<ActionType>(value, out var newType)) return;

        var handler = Handlers.FirstOrDefault(h => h.SupportedType == newType);
        if (handler is null) return;

        var newAction = handler.CreateDefaultModel();
        await OnActionChanged.InvokeAsync(newAction);
    }

    private static string GetDisplayName(ActionType actionType)
    {
        var info = typeof(ActionType).GetMember(actionType.ToString());
        if (info.Length == 0) return actionType.ToString();

        var attr = info[0].GetCustomAttributes(typeof(System.ComponentModel.DataAnnotations.DisplayAttribute), false);
        return attr.Length > 0
            ? ((System.ComponentModel.DataAnnotations.DisplayAttribute)attr[0]).Name ?? actionType.ToString()
            : actionType.ToString();
    }
}
